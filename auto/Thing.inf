thing autocompletion information file
all the stuff that goes into tads THINGS

actorAlreadyInMsg
no description available

actorAlreadyOnMsg
no description available

actorNotInMsg
no description available

actorNotOnMsg
no description available

allowPourIntoMe
While it's possible to pour stuff into any container, we probably don't want to allow it on most of them

allowPourOntoMe
The allowPourOntoMe property controls whether we want allow anything to be poured onto this thing (even if it's possible). By default we don't.

alreadyCleanMsg
no description available

alreadyClosedMsg
no description available

alreadyFastenedMsg
no description available

alreadyHasMsg
no description available

alreadyHeldMsg
no description available

alreadyInMsg
Handled on iobj

alreadyLitMsg
no description available

alreadyLockedMsg
Remap the lock action to our remapIn object if we're not lockable but we have a lockable remapIn object (i.e. an associated container).

alreadyMovedToMsg
no description available

alreadyOnMsg
no description available

alreadyOpenMsg
no description available

alreadyPresentMsg
no description available

alreadyThereMsg
If the route we found has at least two elements, then use the first element of the second element as the direction in which we need to travel, and use the Continue action to take a step in that direction.

alreadyWornMsg
no description available

autoGetOutToReach
If an actor within me cannot reach an object from me, should the actor automatically try to get out of me?

autoTakeOnFindHidden
If the actor finds something in a hiddenPrep list and there's nowhere obvious for it go, should he take it? By default the actor should take it if the object he's found it in/under/behind is fixed in place.

bulk
This object's bulk, in arbitrary units (game authors should devise their own bulk scale according to the needs of their game).

bulkCapacity
The maximum bulk that can be contained in this Thing. We set a very large number by default.

canAttachToMe
no description available

canAttackWithMe
By default we can't use most things as weapons

canBurnWithMe
By default we assume most things can't be used to burn other things with.

canCleanWithMe
We assume most objects aren't suitable for cleaning other objects with. Since the dobj is resolved first canCleanWithMe could be a method that checks whether the proposed iobj is suitable for cleaning gDobj; but a better way of doing it might be to list suitable objects in the mustBeCleanedWith property.

canClimbDownMe
no description available

canClimbUpMe
no description available

canCutWithMe
Most things can't be used to cut other things with

canDetachFromMe
no description available

canDigWithMe
Most objects aren't suitable digging instruments

canEnterOnMe
Entering something on means ENTER FOO ON BAR where FOO is a string literal and BAR is an object such as a computer terminal. Most objects can't be entered on in this sense.

canFastenToMe
no description available

canGoThrougMe
Most things cannot be gone through

canHearIn
Can we hear in from my exterior to my interior? That is, can an observer on the outside of this container hear a sound source on the inside?
By default, we can hear in for all containers, since most materials transmit at least some sound even if they're opaque to light. For a soundproof material (a glass booth, say), you could override this to make it (!enclosing) instead.

canHearOut
Can we hear out from my interior to my exterior? That is, can an observer on the inside of this container hear a sound source on the outside?
By default, we can hear out for all containers, since most materials transmit at least some sound even if they're opaque to light. For a soundproof material (a glass both, say), you could override this to make it (!enclosing) instead.

canJumpOffMe
It should be possible to jump off something if and only if the actor is on it in the first place.

canJumpOverMe
It usually isn't possible (or at least useful) to jump over things.

canLieOnMe
no description available

canLockWithMe
Usually, if something can be used to unlock things it can also be used to lock them

canLookBehindMe
By default we make it possible to look behind things, but there could be many things it makes no sense to try to look behind.

canLookThroughMe
By default we make it possible to look through things, but there may well be things you obviously couldn't look through.

canLookUnderMe
We can look under most things, but there are some things (houses, the ground, sunlight) it might not make much sense to try looking under.

canMoveToMe
In general there's no reason why most objects can't be moved to.

canMoveWithMe
Most things can't be used to move other things with. Note that since the dobj is resolved first, objects or subclasses could override this with a method that returns true or nil depending on the identity of the dobj.

cannotAttachMsg
no description available

cannotAttachToMsg
no description available

cannotAttachToSelfMsg
no description available

cannotAttackMsg
In case isAttackable is changed to true but no other handling is added, we need to provide some kind of default report.

cannotAttackWithMsg
no description available

cannotAttackWithSelfMsg
no description available

cannotBoardMsg
no description available

cannotBreakMsg
no description available

cannotBurnMsg
no description available

cannotBurnWithMsg
no description available

cannotCleanMsg
no description available

cannotCleanWithMsg
no description available

cannotClimbDownMsg
no description available

cannotClimbMsg
no description available

cannotCloseMsg
no description available

cannotConsultMsg
no description available

cannotCutMsg
no description available

cannotCutWithMsg
no description available

cannotCutWithSelfMsg
no description available

cannotDetachFromMsg
no description available

cannotDetachFromSelfMsg
no description available

cannotDetachMsg
no description available

cannotDigMsg
no description available

cannotDigWithMsg
no description available

cannotDigWithSelfMsg
no description available

cannotDoffMsg
no description available

cannotDrinkMsg
no description available

cannotDropMsg
The message to display if something can't be dropped.

cannotEatMsg
no description available

cannotEnterMsg
no description available

cannotEnterOnMsg
no description available

cannotExtinguishMsg
no description available

cannotFastenMsg
no description available

cannotFastenToMsg
no description available

cannotFastenToSelfMsg
no description available

cannotFeelMsg
no description available

cannotFlipMsg
no description available

cannotFollowMsg
no description available

cannotFollowSelfMsg
no description available

cannotGetInCarriedMsg
no description available

cannotGetOnCarriedMsg
no description available

cannotGiveToMsg
no description available

cannotGiveToSelfMsg
no description available

cannotGoNearThereMsg
no description available

cannotGoThroughMsg
no description available

cannotJumpOffMsg
Jumping off something has much the same effect as getting off it, i.e. moving the actor to our exitLocation.

cannotJumpOverMsg
no description available

cannotKissMsg
It's more logical to kiss actors, so we give the Kiss action a lower logical rank on ordinary things.

cannotLieOnMsg
no description available

cannotLightMsg
no description available

cannotLockWithMsg
no description available

cannotLockWithSelfMsg
no description available

cannotLookBehindMsg
Otherwise just display our lookBehindMsg

cannotLookThroughMsg
no description available

cannotLookUnderMsg
Otherwise just display our lookUnderMsg

cannotMoveMsg
no description available

cannotMoveToMsg
no description available

cannotMoveToSelfMsg
no description available

cannotMoveWithMsg
no description available

cannotMoveWithSelfMsg
no description available

cannotOpenMsg
no description available

cannotPlugIntoMsg
no description available

cannotPlugIntoSelfMsg
no description available

cannotPlugMsg
no description available

cannotPourIntoMsg
no description available

cannotPourIntoSelfMsg
no description available

cannotPourMsg
no description available

cannotPourOntoMsg
no description available

cannotPourOntoSelfMsg
no description available

cannotPullMsg
no description available

cannotPurloinContainerMsg
no description available

cannotPurloinRoomMsg
no description available

cannotPurloinSelfMsg
Note that the player char has seen the purloined item. Not doing this can make it appear that the player character doesn't know about an object that's in his/her inventory.

cannotPushDownMsg
no description available

cannotPushIntoMsg
no description available

cannotPushMsg
no description available

cannotPushOwnContainerMsg
no description available

cannotPushThroughMsg
no description available

cannotPushUpMsg
no description available

cannotPushViaSelfMsg
no description available

cannotPutBehindMsg
If we're actually a rear-like object (i.e. if our contType is Behind) then something put behind us can be moved inside us. Otherwise, all we can do with something put behind us is to add it to our hiddenBehind list and move it off-stage.

cannotPutInMsg
If we're actually a container-like object (i.e. if our contType is In) then something put in us can be moved inside us. Otherwise, all we can do with something put in us is to add it to our hiddenIn list and move it off-stage.

cannotPutInSelfMsg
no description available

cannotPutMsg
The most usual reason why we can't put something somewhere is that we can't pick it up in the first place, so by default we'll just copy cannotPutMsg from cannotTakeMsg.

cannotPutOnMsg
no description available

cannotPutUnderMsg
If we're actually an underside-like object (i.e. if our contType is Under) then something put under us can be moved inside us. Otherwise, all we can do with something put under us is to add it to our hiddenUnder list and move it off-stage.

cannotReadMsg
no description available

cannotRemoveMsg
Note that this message should never display in an English-language game since removeDoer will intercept the action before it gets to this point.

cannotScrewMsg
no description available

cannotScrewWithMsg
no description available

cannotScrewWithSelfMsg
no description available

cannotSetMsg
no description available

cannotSetToMsg
no description available

cannotShowToMsg
no description available

cannotShowToSelfMsg
no description available

cannotSitOnMsg
no description available

cannotSmellMsg
no description available

cannotStandOnMsg
no description available

cannotTakeFromSelfMsg
no description available

cannotTakeMsg
Report that we've been taken. Note that if the action causes several items to be taken, this method will only be called on the final item, and will need to report on all the items taken.

cannotTakeMyContainerMsg
no description available

cannotTakeSelfMsg
no description available

cannotTalkToMsg
no description available

cannotTalkToSelfMsg
no description available

cannotTasteMsg
no description available

cannotThrowAtMsg
Particular instances will nearly always need to override with a less generic and more plausible refusal message.

cannotThrowAtSelfMsg
no description available

cannotThrowMsg
The default result of throwing something in a compass direction is that it lands in the dropLocation of its outermost room.

cannotThrowToMsg
no description available

cannotThrowToSelfMsg
no description available

cannotTurnMsg
no description available

cannotTurnToMsg
no description available

cannotTurnWithMsg
no description available

cannotTurnWithSelfMsg
no description available

cannotTypeOnMsg
no description available

cannotUnfastenFromMsg
no description available

cannotUnfastenFromSelfMsg
no description available

cannotUnfastenMsg
no description available

cannotUnlockWithMsg
no description available

cannotUnlockWithSelfMsg
no description available

cannotUnplugFromMsg
no description available

cannotUnplugFromSelfMsg
no description available

cannotUnplugMsg
no description available

cannotUnscrewMsg
no description available

cannotUnscrewWithMsg
no description available

cannotUnscrewWithSelfMsg
no description available

cannotWearMsg
no description available

cannotWriteOnMsg
no description available

canPlugIntoMe
no description available

canPourIntoMe
Presumably it's possible by default to pour something into me if I'm a container; but this could be overridden simply to true for objects like the sea or a river.

canPourOntoMe
Most things can probably have something poured onto them in principle, though we might want to prevent it in practice. The canPourOntoMe property controls whether it's possible to pour onto this thing.

canPushTravel
By default we can't push travel most things. Push Travel means pushing an object from one place to another and traveling with it.

canPutBehindMe
Flag: can under objects be placed behind us? By default they can if our contType is Behind. If this is set to true and our contType is not Behind, anything placed behind us will be treated as hidden behind.

canPutInMe
Flag: can under objects be placed inside us? By default they can if our contType is In. If this is set to true and our contType is not In, anything placed in us will be treated as hidden in.

canPutUnderMe
Flag: can under objects be placed under us? By default they can if our contType is Under. If this is set to true and our contType is not Under, anything placed under us will be treated as hidden under.

canReachIn
Can we reach in from my exterior to my interior? That is, can an observer outside this object reach something inside of it? By default, we can reach in if we're non-enclosing.

canReachOut
Can we reach out from my interior to my exterior? That is, can an observer inside this object reach something outside of it? By default, we can reach out if we're non-enclosing.

canScrewWithMe
Most things can't be used to screw other things with.

canSeeIn
Can we see in from my exterior to my interior? That is, can an observer outside of this object see things located within it? By default, we can see in from outside if we're transparent or we're non-enclosing.

canSeeOut
Can we see out from my interior to my exterior? That is, can an observer inside this object see things located outside of it? By default, we can see out from inside if we're transparent or we're non-enclosing.

canSetMeTo
no description available

canSitOnMe
Although we don't track postures as such, some objects may be better choices than other for sitting on (e.g. chairs), lying on (e.g. beds) and standing on (e.g. rugs), so we allow these to be tested for individually at the verify stage.

canSmellIn
Can we smell in (from an observer on my exterior to an odor source on my interior)? By default, we can smell in if we're non-enclosing, since most solid materials aren't very permeable to scents (at human sensitivities, at least).

canSmellOut
Can we smell out (from an observer on my interior to an odor source on my exterior)? By default, we can smell out if we're non-enclosing, since most solid materials aren't very permeable to scents (at human sensitivities, at least).

canStandOnMe
no description available

canTalkToMe
We don't bother to define isAskable etc. properties since we assume that no inanimate object can be conversed with, and that game code will use the Actor class to allow conversation. In any case since there's never any difficult in talking about oneself, the various illogicalSelf checks aren't needed.
Indeed, the handling of conversational commands on Thing is minimal; they are simply ruled out at the verify stage, since most Things can't converse. The implementation of these actions that allows conversation to take place is on the Actor class. We do however define a canTalkToMe property so that Actor can use the verify handling defined on Thing by just overriding it.
Things can't be talked to, so game code shouldn't normally override this property; it's there to be overridden on the Actor class.

canThrowAtMe
Most objects can the target of a throw, but it's conceivable that some might be obviously unsuitable

canThrowToMe
Most objects cannot have things thrown to then, since this would imply that they might be able to catch them, which only animate objects can do.

canTurnMeTo
no description available

canTurnWithMe
By default things can't be used to turn other things with

canTypeOnMe
Most things can't be typed on.

canUnfastenFromMe
no description available

canUnlockWithMe
Most things can't be used to unlock with. In practice there's probably little point in overriding this property since if you do want to use something to unlock other things with, you'd use the Key class.

canUnplugFromMe
no description available

canUnscrewWithMe
no description available

canWriteOnMe
Most things can't be written on.

circularlyInMsg
no description available

collectiveGroups
CollectiveGrop, or a list of CollectiveGroups, to which this item belongs.

contents
The list of things directly contained by this object

contentsListed
Flag: should this item's contents be listed? This can be used to control both contentsListedInLook and contentsListedInExamine.

contentsListedInExamine
Flag: should this item's contents be listed when its container is examined.

contentsListedInLook
Flag: should this item's contents be listed as part of a room description (when looking around).

contentsListedInSearch
Flag, should this item's contents be listed when it is searched (by default this is simply true, since it would be odd to have a container that failed to reveal its contents when searched).

contType
This object's containment type - that is, the locType for direct children. This is given as one of the spatial relation types (In, On, Under, Behind etc).

currentInterlocutor
The currentInterlocutor is the Actor this object is currently in conversation with. This property is only relevant on gPlayerChar, but it is defined here rather than on Actor since the player char can be of kind Thing.

curSetting
The value we're currently set to.

darkName
The name to display at the head of a room description when it's dark

decorationActions
The list of actions this object will respond to specifically if isDecoration is true. All other actions will be handled by dobjFor(Default) and/or iobjFor(Default). Game code can override this list (usually to expand it) for decorations that are required to handle additional actions.

directlyHeld
Get everything I'm directly holding, which is everything in my immediate contents which is neither fixed in place nor being worn.

directlyIn
get everything that's directly in me

directlyWorn
get everything I'm directly wearing

distinguishByContents
Can I be distinguished in parser messages by my contents? If so, we can be distinguished (in parser messages) from similar objects by our contents, or lack thereof: "bucket of water" vs "empty bucket". If this is true, our nominalContents property determines the contents we display for this.

dontNeedCleaningObjMsg
no description available

dropItemsBehind
Flag, should any items behind me be left behind when I'm moved; by default, they should.

dropItemsUnder
Flag, should any items behind me be left behind when I'm moved; by default, they should.

dropLocation
The location in which something dropped in me should land.

enclosing
Do we fully enclose our interior contents (true), or only partially (nil)? By default, we assume that our contents are fully enclosed. This can be set to nil for objects that represent spaces that are open on one side, such as a nook in a rock or a create without a lid. For an object that's sometimes fully enclosing and sometimes not, such as a cabinet with a door that can be opened and closed, this should be overridden with a method that figures the current value based on the open/closed state. Note that this only applies to our *interior* contents, such as contents of location type In. Contents that are atop the object or otherwise arranged around the exterior aren't affected by this.

examined
Have we been examined? This is set to true when the player character examines the object. For a room, LOOK AROUND counts as examination, as does triggering a room description by traveling into the room.

examineListed
Flag: is this item listed when its container is examined.

examineLister
The lister to use to list an item's contents when it's examined.

exitLocation
Our exitLocation is the location an actor should be moved to when s/he gets off/out of us.

extContents
Get my list of unenclosed direct contents. This is the subset of my direct contents that have exterior location types (On, Outside, Behind, Under).

familiar
Whether the player character knows of the existence of this object, if if it hasn't been seen. Set to true for objects that the player character should be familiar with at the start of play, or make true when the PC learns of them.

feelDesc
The description displayed in response to a FEEL command

findHiddenDest
Where should an item that's been hidden in/under/behind something be moved to when its found? If it's taken, move into the actor; otherwise move it to the location of the object it's just been found in/under/behind.

fluidName
Sometimes we may have a container, such as an oilcan, from which we want to pour a liquid, such as oil, and we're using the same object to do duty for both. We can then use the fluidName property to say 'the oil' rather than 'the oilcan' in messages that refer specifically to pouring the liquid.

futileToAttackMsg
In case isAttackable is changed to true but no other handling is added, we need to provide some kind of default report.

getBulkHiddenBehind
no description available

getBulkHiddenIn
no description available

getBulkHiddenUnder
The total bulk of items hidden in, under or behind this object

getFacets
A list of objects that are facets of this object, and so can be referred to with the same pronoun.

getOutermostRoom
Our outermost room, i.e. the top level Room in which we are indirectly or directly contained.

globalParamName
Our globalParamName is an arbitrary string value that can be used to refer to this thing in a message substitution parameter; for code readability it may be a good idea to make this a string representation of our programmatic name (where we want to define it at all).

groupOrder
Group order. This gives the relative order of this item within its list group.

hearNothingMsg
no description available

hiddenBehind
A list of objects that are treated as hidden behind this one. A LOOK BEHIND command will list them and move them into the enclosing room. It follows that objects placed in this property should not be given an initial location. This should deal with the most common reason for wanting items to be placed behind things (i.e. to hide them). Note, the items in the hiddenBehind property should also be revealed when the player moves the hiding item.

hiddenIn
A list of objects that are treated as hidden inside this one. A LOOK IN command will list them and move them into the enclosing room (or in this one if we're a container). It follows that objects placed in this property should not be given an initial location.

hiddenUnder
A list of objects that are treated as hidden under this one. A LOOK UNDER command will list them and move them into the enclosing room. It follows that objects placed in this property should not be given an initial location. This should deal with the most common reason for wanting items to be placed under things (i.e. to hide them). Note, the items in the hiddenUnder property should also be revealed when the player moves the hiding item.

indirectLockableMsg
no description available

initSpecialDesc
A specialDesc that's shown until this item has been moved

intContents
Get my list of enclosed direct contents. This is the subset of my direct contents that have interior location types (In).

interiorDesc
The "inside" description. This is displayed when an actor LOOKS AROUND from within this object. Note that this applies not only to top-level rooms but also to things like chairs, platforms, and booths that can contain an actor. By default, we simply show the ordinary EXAMINE description (or the darkDesc if there's no illumination). Non-room containers such as chairs or booths should usually override this to provide the view from inside the object, which usually differs from the ordinary EXAMINE description. For a top-level room, you don't usually override this, since the only description needed for a room is normally the LOOK AROUND perspective.

inventoryListed
Flag: is this item listed in an inventory listing.

isAttachable
By default most things can't be attached to any things. The base handling of ATTACH and DETACH on Thing merely rules them out at the verify stage. The SimpleAttachable and NearbyAttachable classes define in the optional attachables.t module provide fuller handling.

isAttackable
Although in theory we can attack almost anything, in practice there's seldom reason to do so.

isBoardable
Can an actor enter (get in or on) this object. Note that for such an action to be allowing the contType must also match the proposed action.

isBreakable
By default treat everything as breakable, but there are somethings that clearly aren't like sunbeams, sounds and mountains.

isBurnable
By default we assume most things aren't burnable

isClean
Assume most things start out not as clean as they could be

isCleanable
Most things probably could be cleaned, even if they're not worth cleaning in practice. Some things like a mountain or the moon probably can't be cleaned and could reasonably define isCleanable = nil.

isClimbable
Most things can't be climbed

isCloseable
By default something is closeable if it's openable

isConsultable
Most things aren't consultable

isCuttable
By default things can't be cut

isDecoration
If I declare this object to be a decoration (i.e. isDecoration = true) then its default behaviour will be to display its notImportantMsg for every action except Examine or GoTo. We can extend the actions it will respond to by adding them to the list in the decorationActions property.

isDetachable
no description available

isDiggable
Most things are not suitable for digging in

isDoffable
By default we assume that something's doffable if it's wearable

isDrinkable
Most things aren't drinkable

isDroppable
By default we can drop anything that's held

isEdible
Flag: Can this thing be eaten

isEnterable
Flag, can we enter (i.e. get inside) this thing? For most objects, we can't

isExtinguishable
Most things are extinguishable if they're lit, but some things (like the sun or a nuclear explosion) might conceivably not be. Note that this property should only be set to nil for things that couldn't be extinguished even if they were lit (the flames of Hell, for example, which might be considered undousable for all eternity, if you're bent on writing an infernal game).

isFastenable
Fasten by itself presumably refers to objects like seat-belts. There are not many such fastenable objects so we may things not fastenable by default.

isFastened
Most things start out unfastened.

isFeelable
By default we can try feeling most things, but there may be some things it would be inappropriate to try feeling (like a blazing fire or Aunt Mable) or somethings that cannot be felt (like a ray of light).

isFixed
Flag to indicate whether this item is portable (nil) or fixed in place (true). If it's fixed in place it can't be picked up or moved around (by player commands).

isFlippable
Since FLIP X is often synonymous with SWITCH X , by default we make something flippable if it's switchable.

isFollowable
Flag: can this object be followed? Most inanimate objects cannot, so the default value is nil.

isHidden
Flag, do we want to treat this object as hidden from view (so that the player can't interact with it)?

isKissable
We can try kissing most things, even if it isn't very rewarding

isLightable
Is this object lightable (via a player command)? Note that setting this property to true also automatically makes the LitUnlit State applicable to this object, allowing it to be referred to as 'lit' or 'unlit' as appropriate.

isListed
A global isListed property that can be used to set the value of all the others. By default we're listed if we're not fixed in place.

isLit
Is this object lit, i.e. providing sufficient light to see not only this object but other objects in the vicinity by.

isLocked
Flag: is this object currently locked. By default we start out locked if we're lockable.

isMoveable
By default we assume anything fixed isn't moveable. That's not necessarily the case since we may be able to move something by pushing it around (say) even if we can't pick it up.

isOn
is this item currently switched on?

isOpen
Is this object open. By default we'll make Things open so that their interiors (if they have any) are accessible, unless they're openable, in which case we'll assume they start out closed.

isOpenable
Is this object openable. If this property is set to true then this object can be open and closed via the OPEN and CLOSE commands. Note that setting this property to true also automatically makes the OpenClosed State apply to this object, so that it can be referred to as 'open' or 'closed' accordingly.

isPlayerChar
Is this object the player character?

isPlugable
Most things can't be plugged into other things or have other things plugged into them.

isPourable
Most things aren't pourable (they can't be poured into or onto other things.

isProminentNoise
Is the this object's listenDesc displayed in response to an intransitive LISTEN command? (Only relevant if listenDesc is not nil)

isProminentSmell
Is the this object's smellDesc displayed in response to an intransitive SMELL command? (Only relevant if smellDesc is not nil)

isPullable
We can at least try to pull most things.

isPushable
We can at least try to push most things.

isReadable
By default an object is readable if it defines a non-nil readDesc

isRemoveable
By default an object is removeable if it's takeable

isScrewable
Most things can't be screwed

isSettable
Most things aren't settable.

isSmellable
By default everything is smellable, but you can override this to nil if something isn't

isSwitchable
Can this object be switched on and off?

isTakeable
By default a Thing is takeable if it's not fixed in place

isTasteable
By default everything is tasteable, but there might well be things the that it would not be appropriate to taste.

isThrowable
By default something is throwable unless it's fixed in place.

isTransparent
Are we transparent to light? If this is true, then an observer outside this object can see through it to objects on its interior, and an observer inside can see through to objects on its exterior. This property controls transparency symmetrically (looking in from outside and looking out from within). The library also lets you control transparency asymmetrically, using canSeeIn and canSeeOut. Those values are by default derived from this one, but you can override them separately to create something like a one-way mirror.

isTurnable
By default we make everything turnable, but lots of things clearly won't be.

isUnfastenable
no description available

isUnplugable
no description available

isUnscrewable
no description available

isVehicle
Flag; is this Thing a vehicle for an actor? If so then issuing a travel command while in this vehicle will call this vehicle to travel

isWearable
is this object something that can be worn

keyDoesntWorkMsg
If we've found a possible key but it doesn't actually work on this object, report that we're trying this key but it doesn't work.

keyList
A list of Keys that can be used to lock or unlock this Thing. Any Keys in this list will cause this Thing to be added to the plausible and actual lock lists of that Key at PreInit. This provides an alternative way of specifying the relation between locks and keys.

keyNotNeededMsg
no description available

known
Test whether this Thing is known to the player character.

knownKeyList
A list of Keys that the player character starts out knowing at the start of the game can lock our unlock this Thing.

knownProp
If we want to track whether characters other than than the player char know about or have seen this object, we can define knownProp and seenProp as the properties used by this Thing to track what it knows about and has seen.

lastSeenAt
The last location where the player character saw this object. Whenever the object is described or listed in the description of a room or another object, we set this to the object's location at that time.

lieOnScore
no description available

listableContents
The subset of our contents that should be listed.

listenDesc
The description displayed in response to a LISTEN command

listOrder
Listing order. This is an integer giving the relative position of this item in a miscellaneous item list. The list is sorted in ascending order of this value.

listWith
List group. At the moment this does nothing, but it has been retained from the Mercury library for possible future use.

location
The location of this object, i.e. this object's immediate container (which may be another Thing, a Room, or an Actor such as the player char). Note that while you should specify the initial location of an object via this property you should never directly alter this property in game code thereafter; to change the location on object during the the course of a game use the moveInto(loc) or actionMoveInto(loc) method.

lockability
The lockability property determines whether this object is lockable and if so how. The possible values are notLockable, lockableWithoutKey, lockableWithKey and indirectLockable.

lockedMsg
no description available

lookBehindMsg
no description available

lookInMsg
By default our lookInMsg just says the actor finds nothing of interest in us; this could be overridden for an objecy with a more interesting interior.

lookListed
Flag: is this item listed in a room description (when looking around).

lookThroughMsg
no description available

lookUnderMsg
no description available

maxBulkHiddenBehind
no description available

maxBulkHiddenIn
no description available

maxBulkHiddenUnder
The maximum bulk that can be hidden under, behind or in this object, assuming that the player can put anything there at all. Note that this only affects what the player can place there with PUT IN, PUT UNDER and PUT BEHIND commands, not what can be defined there initially or moved there programmatically.

maxSingleBulk
The maximum bulk that a single item may have to be inserted into (onto, under, behind) this object; by default this is the same as the bulk capacity, but you could set a lower value, e.g. to model a bottle with a narrow neck.

mentioned
Has this item been mentioned yet in a room description. Note that this flag is used internally by the library; it shouldn't normally be necessary to manipulate it directly from game code.

moved
Has this object ever been moved by the player character? This is set to true when the PC takes the object or puts it somewhere.

movedTo
The notional location (other object) this object has been moved to as the result of a MoveTo command.

moveNoEffectMsg
no description available

mustBeCleanedWith
If this is non-nil then this is an object or a list of objects that must be/can be used to clean this object.

needsCleaning
But that most things don't actually need cleaning in the game

noLongerTalkingToAnyoneMsg
no description available

nominalContentsOVERRIDDEN
My nominal contents is the special contents item we can use in naming the object. This is useful for containers whose identities come primarily from their contents, such as a vessel for liquids or a box of loose files. Returns an object that qualifies the name: a "water" object for BOX OF WATER, a "files" object for BOX OF FILES. Nil means that the object isn't named by its contents. Note that this is always a single object (or nil), not the whole list of contents. We can only be named by one content object. (So you can't have a "box of books and papers" by having separate nominal contents objects for the books and the papers; although you could fake it by creating a "books and papers" object.)

noNeedToCleanMsg
no description available

notFastenedMsg
no description available

notHoldingMsg
And I can't drop something that game code has deemed to be not droppable for some other reason.

notImportantMsg
no description available

notInMsg
We're also a poor choice if none of the tentative direct objects is in our list of notional contents

notLitMsg
no description available

notLockableMsg
If we are lockable with key, then were a good choice of object for an UnlockWith action provided we're currently locked.

notLockedMsg
no description available

notSwitchableMsg
no description available

notTalkingToAnyoneMsg
no description available

notWornMsg
no description available

objInPrep
The preposition that should be used to describe containment within this thing (e.g. 'in', 'on' , 'under' or 'behind'). By default we get this from our contType.

objIntoPrep
The preposition that should be used to describe movement to within this thing (e.g. 'into', 'onto' , 'under' or 'behind'). By default we get this from our contType.

okayCleanMsg
no description available

okayGetOutOfMsg
no description available

okayLockMsg
Make us locked.

okayOpenMsg
If opening us is not being performed as an implicit action, list the contents that are revealed as a result of our being opened.

okayPushIntoMsg
no description available

okayPushOutOfMsg
no description available

okayUnlockMsg
Make us unlocked.

opened
Flag, has this object ever been opened. Note that this is nil for an object that starts out open but has never been closed and opened again.

openStatusReportable
Do we want this object to report whether it's open? By default we do if it's both openable and open.

owner
The owner or owners of the object. This is for resolving possessives in the player's input, such as BOB'S WALLET. By default, an object has no explicit owner, so this is an empty list. This should only return the *explicit* owner(s), not an implied locational owner. For example, if Bob is holding a key, it's implicitly BOB'S KEY. However, the key may or may not still be Bob's after he drops it. If the key is something that's understood to belong to Bob, whether it's currently in his physical possession or not, then this routine would return Bob; otherwise it would return nil. An object can have multiple explicit owners, in which case it'll be recognized with a possessive qualifier for any of the owners. The first owner in the list is the nominal owner, meaning its the one we'll use if we're called upon to display the object's name with a possessive phrase.

ownsContents
Are we the nominal owner of the objects we contain? This controls whether or not we can be chosen as the nominal owner of a contained object for display purposes. If a contained object has no explicit owner, it can still be implicitly owned by an actor carrying it, or by another suitable container. (Note that this only applies as a default. When an item in our contents has an explicit owner, that will override the implied container ownership for that item. So, for example, Bob can be carrying Bill's wallet wallet, and as long as the wallet has its explicit owner set, we'll still describe it as Bill's despite its location.) By default, most objects are not nominal owners. Actors generally should set this to true, so that (for example) anything Bob is carrying can be described as Bob's. Something with contType = Carrier is likely to be an actor and hence something that can own its contents.

paraBrksBtwnSubcontents
Do we want paragraph breaks between the listings of subcontents (i.e. the contents of this item's contents)? By default we take our value from the global setting on gameMain.

partOfYouMsg
no description available

preCondActor
no description available

pullNoEffectMsg
no description available

pushNoEffectMsg
no description available

readDesc
The text we display in response to a READ command. This can be nil (if we're not readable), a single-quoted string, a double-quoted string

recognizableInDark
Can the player character recognize this room (enough to know its name and have a rough idea of its location) in the dark? (If so then looking around in this room in the dark makes it visited and familiar, otherwise it doesn't).

remapActor
If our contType isn't Carrier we're unlikely to be an actor, so we're a poor choice of object if the parser has to select an actor, typically when the player has entered a command targeted at an NPC.

remapBehind
If non-nil, remapUnder specified the object that acts as our proxy rear, i.e. the object to which any PUT BEHIND or LOOK BEHIND action directed at us will be redirected.

remapIn
If remapIn is not nil, a LOOK IN, PUT IN, OPEN, CLOSE, LOCK or UNLOCK command performed on this Thing will be redirected to the object specified on remapIn. In other words, remapIn specifies the object that acts as our proxy container.

remapOn
If non-nil, remapOn speficies the object that acts as our proxy surface, in other words the object to which PUT ON will be redirected.

remapUnder
If non-nil, remapUnder specified the object that acts as our proxy underside, i.e. the object to which any PUT UNDER or LOOK UNDER action directed at us will be redirected.

roomContentsLister
The contents lister to use for listing this room's miscellaneous contents. By default we use the standard lookLister but this can be overridden to use a CustomRoomLister (say) to provide just about any wording we like.

roomTitleOVERRIDDEN
The name to display at the head of a room description

searchListed
Flag: is this item listed when is container is searched (or looked in).

seen
Have we been seen? This is set to true the first time the object is described or listed in a room description or the description of another object (such as LOOK IN this object's container).

seenProp
no description available

shouldBeBroken
Probably most things shouldn't be broken though.

shouldNotBreakMsg
no description available

shouldNotPourIntoMsg
no description available

shouldNotPourOntoMsg
no description available

sightSize
The sightSize can be small, medium or large and controls how visible this object is from a remote location. If it's small, it can't be seen from a remote location at all. It it's medium, the object can be seen, but it's not possible to discern any detail. If it's large, it can be seen and described. Note that this behaviour is only the default, however, since it can be changed by overriding the isVisibleFrom() and remoteDesc() methods. Note also that sightSize is not related to the bulk property (unless you override sightSize to make it so).

sitOnScore
As well as ruling out certain objects for sitting, lying or standing on, we can also give them a score for each of these postures; e.g. a bed may be particularly suitable for lying on (although you could lie on the sofa) while a chair may be particularly suitable for sitting on (though you could sit on the bed. By default we'll give each posture a score of 100, the normal logical verify score. Note that these scores have no effect if the corresponding can xxxOnMe property is nil.

smellDesc
The description displayed in response to a SMELL command

smellNothingMsg
no description available

smellSize
The smellSize can be small, medium or large. By default something is smellable from a remote location either if its smellSize is large or if it smellSize is not small and its remoteSmellDesc() method has been defined. Overriding isSmellableFrom(pov) may change these rules.

soundSize
The soundSize can be small, medium or large. By default something is audible from a remote location either if its soundSize is large or if it soundSize is not small and its remoteListenDesc() method has been defined. Overriding isAudibleFrom(pov) may change these rules.

specialDesc
If present, a description of this object shown in a separate paragraph in the listing of the contents of a Room. If specialDesc is defined then this paragraph will be displayed regardless of the value of isListed.

specialDescBeforeContents
Is this item listed before or after the list of miscellaneous contents in the room. By default we'll show the specialDesc of items before miscellaneous items in a room description but afterwards otherwise: this places specialDescs in a more logical order in relation to the text of listers used to list the contents of obejcts other than rooms.

specialDescListWith
For possible future use; at the moment this doesn't do anything

specialDescOrder
The specialDescOrder property controls where in a series of specialDesc paragraphs this item is mentioned: the higher the number, the later it will come relative to other items. Note that this does not override the specialDescBeforeContents setting.

stagingLocation
Our staging location is where we need to be to get on/in us

standOnScore
no description available

stateDesc
The state-specific description of this object, which is appended to its desc when examined. This is defined as a single-quoted string to make it easy to change at run-time.

tasteDesc
The description displayed in response to a TASTE command

throwFallsShortMsg
no description available

tooDarkToSeeMsg
The message to display when it's too dark to see anything

tooFarAwayToHearMsg
Otherwise say this object is too far away for the actor to hear.

tooFarAwayToReadMsg
no description available

tooFarAwayToSeeDetailMsg
Otherwise say this object is too far away for the actor to see any detail.

tooFarAwayToSmellMsg
Otherwise say this object is too far away for the actor to smell.

turnNoEffectMsg
no description available

useInitSpecialDesc
By default we use the initSpecialDesc until the object has been moved, but this can be overridden with some other condition.

useKey_
no description available

useSpecialDesc
Should the specialDesc be used? Normally we use the specialDesc if we have one, but we may want to override this for particular cases. For example, if we want an item to have a paragraph to itself until it's moved we could define useSpecialDesc = (!moved) [making it equivalent to initSpecialDesc]. Note that the useSpecialDesc property only has any effect if specialDesc is not nil.

viaMode
Note the mode of push travel (a preposition) for use in messages.

visibleInDark
Is this object visible in the dark without (necessarily) providing enough light to see anything else by, e.g. the night sky.

vocabLikelihood
A property that can be used to boost this object being chosen by the parser, other things being equal; it can be used as a tie-breaker between two objects that otherwise have the same verification scores. Game code should normally use fairly small values for this property, say between -20 and +20, to prevent overriding the verification score.

withKeyMsg
no description available

wornBy
If this object is currently being worn by someone, the wornBy property contains the identity of the person wearing it.

actionMoveInto (newCont)
Move into generated by a user action, which includes notifications

actorAction ( )
The before action handling on this Thing if it's the current actor. We define it here rather than on Actor since the player character can be a Thing. By default we do nothing.

addToAllContents (vec, lst)
no description available

addToContents (obj, vec?)
Add an item to this object's contents. Normally this method is used internally in the library than directly by game code. If the vec parameter is supplied, the object added to our contents is also added to vec; again this is intended primarily for internal use by the library.

afterAction ( )
After action notification on this Thing; this is triggered whenever an action has just been performed when we're in scope. The action we'd test for here would normally be one that *doesn't* involve this Thing.

afterTravel (traveler, connector)
no description available

allContents ( )
Return a list of everything that's directly or indirectly contained within us.

allowReachOut (obj)
Check whether the actor can reach out of this object to touch obj, if obj is not in this object.

beforeAction ( )
Before action notification on this Thing; this is triggered whenever an action is about to be performed when we're in scope (and could be used to veto the action with an exit macro). The action we'd test for here would normally be one that *doesn't* involve this Thing.

beforeMovePushable (connector, dir)
Use the travelVia() method of the iobj to move the iobj to its new location.

beforeTravel (traveler, connector)
before and after travel notifications. By default we do nothing

canHear (obj)
Is obj audible from us?

cannotPushTravelMsg ( )
Display a message explaining that push travel is not possible

canReach (obj)
Is obj reachable (by touch) from us?

canSee (obj)
Is obj visible from us?

canSmell (obj)
Is obj smellable from us?

canTalkTo (other)
Can this Thing (which might be the Player Char for instance) talk to other?

checkDisplay (prop)
Check if displaying prop would produce any output.

checkInsert (obj)
Check whether an item can be inserted into this object, or whether doing so would either exceed the total bulk capacity of the object or the maximum bulk allowed for a single item.

checkPushTravel ( )
Check the travel barriers on the indirect object of the action

checkReach (actor)
Check whether the actor can reach (touch) this object. If this method displays anything (which should be the reason this object can't be touched) then the object can't be reached. Note that this only has any effect when the touchObj preCondition is defined.

checkReachIn (actor, target?)
Check whether an actor can reach inside this object (for reasons other that it enclosing its contents; e.g. because it's out of reach). If this method displays anything (which should be the reason the interior of this object can't be reached) then disallow reaching inside. Note that this only has any effect when the touchObj preCondition is defined on this object. By default we can reach inside if we can reach this object and not otherwise. If the optional target parameter is supplied, it's the object that actor is trying to reach.

checkRoomToHold ( )
Check that the actor has enough spare bulkCapacity to add this item to his/her inventory. Since by default everything has a bulk of zero and a very large bulkCapacity, by default there will be no effective restriction on what an actor (and in particular the player char) can carry, but game authors may often wish to give portable items bulk in the interests of realism and may wish to impose an inventory limit by bulk by reducing the bulkCapacity of the player char.

checkSetting (val)
If the setting is valid, do nothing. If it's invalid display a message explaining why. We do nothing here but this is overridden on the Settable class, which may be easier to use than providing your own implementation on Thing.

childLocType (child)
Get the containment relationship between 'child' and 'self'. This returns the containment type of the immediate child of 'self' that contains 'child'.

commonContainingParent (other)
Find the nearest common containing parent of self and other. Unlike commonInteriorParent this doesn't take account of the type of containment (it can be In, On, Under, Behind or anything else) just so long as we find a common parent in the containment hierarchy.

commonInteriorParent (other)
Find the nearest common interior parent of self and other. This finds the nearest parent that both self and other are inside of.

containerPath (other)
Get the interior containment path from 'self' to 'other'. This returns a list containing three elements. The first element is a sublist giving the interior containers you have to traverse outwards from self up to the common interior parent. The second element is the common container; this will be nil if the two objects are in separate rooms. The third element is a sublist giving the containers you have to traverse inwards from the common parent to other.

containerPathBlock (other, inProp, outProp)
Search for a "blockage" along the container path between 'self' and 'other'. 'outProp' and 'inProp' are "can" properties (&canSeeOut, &canReachIn, etc) that test a container to see whether we can see/reach/hear/etc in or out of the container.
We trace the containment path, using traceContainerPath(). For each outbound container on the path, we evaluate the container's outProp property: if this is nil, we add that container to the blockage list. Next, if there's no common parent, we add the outermost room containing 'self' to the list. Next, we trace the inbound path, evaluating each container's inProp property: if nil, we add that container to the blockage list.
Finally, we return the blockage list. This is a vector giving all of the blockages we found, in the order we encountered them.

darkDesc ( )
The description of the room when it's dark

desc ( )
The description of this Thing that's displayed when it's examined. Normally this would be defined as a double-quoted string, but in more complicated cases you could also define it as a method that displays some text.

describeMovePushable (connector, dest)
no description available

describePushTravel (via)
This message, called on the direct object of a PushTravel command (i.e. the object being pushed) is displayed just before travel takes place. It is used when the PushTravel command also involves an indirect object, e.g. a Passage, Door or Stairway the direct object is being pushed through, up or down. The via parameter is the preposition relevant to the kind of pushing, e.g. Into, Through or Up.

directChildParent (other)
Find the immediate child of 'self' that contains 'other'. If 'other' is directly in 'self', we return 'other'; otherwise, we return an object directly within 'self' that contains 'obj', directly or indirectly. If 'other' is not within 'self', we return nil.

discover (stat, =, true)
Make a hidden item unhidden. If the method is called with the optional parameter and the parameter is nil, i.e. discover(nil), the method instead hides the object.

display (prop)
Attempt to display prop appropriately according to it data type (single-quoted string, double-quoted string, integer or code). The prop parameter must be provided as a property pointer.

dobjFor(AskAbout)
no description available

dobjFor(AskFor)
no description available

dobjFor(Attach)
no description available

dobjFor(AttachTo)
no description available

dobjFor(Attack)
no description available

dobjFor(AttackWith)
no description available

dobjFor(Board)
no description available

dobjFor(Break)
no description available

dobjFor(Burn)
no description available

dobjFor(BurnWith)
no description available

dobjFor(Clean)
The handling of the Clean action is possibly more elaborate than it needs to be by default, and game code may wish to override it with a different implementation, but the aim is to provide a framework that covers some common cases. An object starts out with isClean = nil. Cleaning the object makes isClean true (at which point it doesn't need cleaning again). If an object needs another object to be cleaned with (e.g. if in order to clean the window you need a wet sponge to clean it with), this can be defined by setting mustBeCleanedWith to an object or a list of objects that can be used to clean this direct object.

dobjFor(CleanWith)
no description available

dobjFor(Climb)
no description available

dobjFor(ClimbDown)
no description available

dobjFor(ClimbUp)
no description available

dobjFor(Close)
no description available

dobjFor(ConsultAbout)
The base handling on Thing merely rules out the Consult action at the verify stage. For a fuller implementation that allows consulting use the Consultable class.

dobjFor(Cut)
no description available

dobjFor(CutWith)
no description available

dobjFor(Default)
Our handling of any action of which we're the direct or indirect action that's not in our list of decorationActions when our isDecoration property is true. By default we just stop the action at the verify stage and display our notImportantMsg.

dobjFor(Detach)
no description available

dobjFor(DetachFrom)
no description available

dobjFor(Dig)
no description available

dobjFor(DigWith)
For DigWith we merely provide verify handlers that rule out the action wih the default values of isDiggable and canDigWithMe. The library cannot model the effect of digging in general, so it's up to game code to implement this on particular objects as required.

dobjFor(Doff)
no description available

dobjFor(Drink)
no description available

dobjFor(Drop)
no description available

dobjFor(Eat)
no description available

dobjFor(Enter)
Treat Enter X as equivalent to Get In X

dobjFor(EnterOn)
The base handling is simply to rule out EnterOn at verify. There's no further handling the library can provide for a 'general' case so it's up to game code to define it for specific cases.

dobjFor(Examine)
Now the handling for specific actions. Modify the effect of Examine to show the remoteDesc if appropriate, or else our regular desc if our sightSize is large, or else a message to say we're too far away to see any detail. If we're in the same room as the actor, simply carry out the regular (inherited) method.

dobjFor(Extinguish)
no description available

dobjFor(Fasten)
no description available

dobjFor(FastenTo)
no description available

dobjFor(Feel)
no description available

dobjFor(Flip)
no description available

dobjFor(Follow)
no description available

dobjFor(GetOff)
no description available

dobjFor(GetOutOf)
no description available

dobjFor(GiveTo)
no description available

dobjFor(GiveToImplicit)
no description available

dobjFor(GoNear)
The GoNear action allows the player character to teleport around the map.

dobjFor(GoThrough)
no description available

dobjFor(GoTo)
The GoTo action allows the player character to navigate the map through the use of commands such as GO TO LOUNGE.

dobjFor(JumpOff)
no description available

dobjFor(JumpOver)
The base handling of JumpOver is simply to rule it out at the verify stage.

dobjFor(Kiss)
no description available

dobjFor(LieIn)
no description available

dobjFor(LieOn)
no description available

dobjFor(LieOn)
no description available

dobjFor(Light)
Lighting an object makes it a light source by making its isLit property true.

dobjFor(ListenTo)
Modify the effect of ListenTo to show the remoteListenDesc if appropriate, or else our regular listenDesc if our soundSize is large, or else a message to say we're too far away to hear. If we're in the same room as the actor, simply carry out the regular (inherited) method.

dobjFor(Lock)
no description available

dobjFor(LockWith)
no description available

dobjFor(LookBehind)
no description available

dobjFor(LookIn)
no description available

dobjFor(LookThrough)
no description available

dobjFor(LookUnder)
no description available

dobjFor(Move)
Moving an object is generally possible if the object is portable, but there's no obvious effect, so by default this action does nothing except say it's done nothing.

dobjFor(MoveTo)
MoveTo is a more complex case than MOVE or MOVE WITH. In this implementation we assume that it represents moving the direct object to the vicinity of the indirect object, and so we track the object it's been moved to. This might be useful, say, if you wanted the player to have to MOVE the chair TO the bookcase before being able to reach the top shelf by standing on the chair, since you could then check the value of the chair's movedTo property before deciding whether the top shelf was accesssible.

dobjFor(MoveWith)
no description available

dobjFor(Open)
no description available

dobjFor(PlugIn)
no description available

dobjFor(PlugInto)
The base handling of PlugInto on Thing merely rules it out at the verify stage. A fuller implementation is provided by the PlugAttachable class in the optional attachables module.

dobjFor(Pour)
The base handling of Pour, PourOnto and PourInto is simply to rule out all three actions at the verify stage. Game code that wants to allow these actions on specific objects will need to provide further handling for them.

dobjFor(PourInto)
no description available

dobjFor(PourOnto)
no description available

dobjFor(Pull)
no description available

dobjFor(Purloin)
PURLOIN allows the player to move any portable object in the game directly into his/her inventory, wherever it is currently. We don't allow absolutely anything to be purloined, as this could cause chaos.

dobjFor(Push)
no description available

dobjFor(PushTravelClimbDown)
no description available

dobjFor(PushTravelClimbUp)
no description available

dobjFor(PushTravelDir)
PushTravelDir handles pushing an object in a particular direction, e.g. PUSH BOX NORTH

dobjFor(PushTravelEnter)
PushTravelEnter handles commands like PUSH BOX INTO COFFIN, where the indirect object is a Booth-like object. The syntactically identical command for pushing things into an Enterable (e.g. PUSH BOX INTO HOUSE where HOUSE represents the outside of a separate location) is handled on the Enterable class.

dobjFor(PushTravelGetOutOf)
no description available

dobjFor(PushTravelThrough)
PushTravelThrough handles pushing something through something, such as a door or archway. Most of the actual handling is dealt with by the common routines defined above.

dobjFor(PutBehind)
no description available

dobjFor(PutIn)
no description available

dobjFor(PutOn)
no description available

dobjFor(PutUnder)
no description available

dobjFor(QueryAbout)
no description available

dobjFor(Read)
Modify the effect of a Read action to prevent this item being read from a remote location unless isReadableFrom(gActor) is true.

dobjFor(Remove)
We'll take REMOVE to mean DOFF when it's dobj is worn and TAKE otherwise. This handling will be dealt with by removeDoer insteadof remap, since this form of remap has now been discontinued. See english.t for removeDoer (which seems to be a language-specific construct)

dobjFor(SayTo)
no description available

dobjFor(Screw)
In the base handling we simply rule out Screw and Unscrew actions at the verify stage. It's up to game code to provide specific handling for objects that can be screwed and unscrewed.

dobjFor(ScrewWith)
no description available

dobjFor(Search)
Treat SEARCH as equivalent to LOOK IN

dobjFor(Set)
The Set command by itself doesn't do much. By default we just rule it out at the verify stage.

dobjFor(SetTo)
no description available

dobjFor(ShowTo)
no description available

dobjFor(ShowToImplicit)
no description available

dobjFor(SitIn)
no description available

dobjFor(SitOn)
no description available

dobjFor(SitOn)
no description available

dobjFor(SmellSomething)
Modify the effect of SmellSomething to show the remoteSmellDesc if appropriate, or else our regular smellDesc if our smellSize is large, or else a message to say we're too far away to smell. If we're in the same room as the actor, simply carry out the regular (inherited) method.

dobjFor(StandIn)
By default we'll treat standing, sitting or lying IN something as simply equivalent to entering it.

dobjFor(StandOn)
Since we don't track postures in this library we'll treat STAND ON as equivalent to BOARD

dobjFor(StandOn)
no description available

dobjFor(Strike)
no description available

dobjFor(SwitchOff)
no description available

dobjFor(SwitchOn)
no description available

dobjFor(SwitchVague)
no description available

dobjFor(Take)
no description available

dobjFor(TakeFrom)
We treat TAKE FROM as equivalent to TAKE except at the verify stage, where we first check that the direct object is actually in the indirect object.

dobjFor(TakeFrom)
no description available

dobjFor(TalkAbout)
no description available

dobjFor(TalkTo)
no description available

dobjFor(Taste)
no description available

dobjFor(TellAbout)
no description available

dobjFor(Throw)
no description available

dobjFor(ThrowAt)
no description available

dobjFor(ThrowDir)
no description available

dobjFor(ThrowTo)
no description available

dobjFor(Turn)
no description available

dobjFor(TurnTo)
Turning something To is setting it to a value by rotating it, such as turning a dial to point to a particular number.

dobjFor(TurnWith)
no description available

dobjFor(TypeOn)
no description available

dobjFor(TypeOnVague)
The base handling of both the vague (TYPE ON X) and specific (TYPE FOO ON X) forms of TypeOn is simply to rule them out at the verify stage. Game code that needs objects that can be typed on is responsible for handling these actions in custom code.

dobjFor(Unfasten)
no description available

dobjFor(UnfastenFrom)
no description available

dobjFor(Unlock)
no description available

dobjFor(UnlockWith)
Note: we don't use isLockable, because this is not a binary property; there are different kings of lockability and defining an isLockable property in addition would only confuse things and might break the logic.

dobjFor(Unplug)
no description available

dobjFor(UnplugFrom)
no description available

dobjFor(Unscrew)
no description available

dobjFor(UnscrewWith)
no description available

dobjFor(Wear)
no description available

dobjFor(WriteOn)
By default we simply rule out writing on things at the verify stage.

doPushTravel (via)
Carry out the push travel on the direct object of the action.

examineStatus ( )
Additional information to display after our desc in response to an EXAMINE command.

findHidden (prop, prep)
If there's something hidden in the dobj but nowhere obvious to move it to then by default we move everything from the hiddenIn list to the actor's inventory and announce that the actor has taken it. We call this out as a separate method to make it easy to override if desired.

findPlausibleKey (silent, =, nil)
Find a key among the actor's possessions that might plausibly lock or unlock us. If the silent parameter is true, then don't report a failed attempt.

firstContainerPathBlock (other, inProp, outProp)
Get the first blockage in a container path. This calls containerPathBlock() and returns the first blockage in the list, or nil if there's no blockage.

getBulkWithin ( )
Calculate the total bulk of the items contained within this object.

getCarriedBulk ( )
Calculate the total bulk carried by an actor, which excludes the bulk of any items currently worn or anything fixed in place.

getStatuslineExitsHeight ( )
Get the estimated height, in lines of text, of the exits display's contribution to the status line. This is used to calculate the extra height we need in the status line, if any, to display the exit list. If we're not configured to display exits in the status line, this should return zero.

handleCommand (action)
Handle a command directed to this open (e.g. BALL, GET IN BOX). Since inanimate objects generally can't respond to commands we simply display a message announcing the futility of issuing one. This method is overridden on Actor to allow Actors to respond to commands via CommandTopics.

hasSeen (obj)
Test whether this Thing has seen obbj.

hideFromAll (action)
To exclude this item from the list of objects to be acted upon when the player types a command with ALL for action, override this method to return true for the action or actions concerned. Note that this exclusion is applied after the action has constructed its own list of objects that ALL should apply to, and can only be used to make further exclusions. It shouldn't be necessary to use this method very often, since the normal approach will be to override the getAll() method on the appropriate action. It may be useful to use this method to handle exceptional cases, however.

interiorParent ( )
no description available

iobjFor(AttachTo)
no description available

iobjFor(AttackWith)
no description available

iobjFor(BurnWith)
no description available

iobjFor(CleanWith)
no description available

iobjFor(CutWith)
no description available

iobjFor(Default)
no description available

iobjFor(DetachFrom)
no description available

iobjFor(DigWith)
no description available

iobjFor(FastenTo)
no description available

iobjFor(GiveTo)
no description available

iobjFor(LockWith)
no description available

iobjFor(MoveTo)
no description available

iobjFor(MoveWith)
no description available

iobjFor(PlugInto)
no description available

iobjFor(PourInto)
no description available

iobjFor(PourOnto)
no description available

iobjFor(PushTravelClimbDown)
no description available

iobjFor(PushTravelClimbUp)
no description available

iobjFor(PushTravelEnter)
no description available

iobjFor(PushTravelGetOutOf)
no description available

iobjFor(PushTravelThrough)
no description available

iobjFor(PutBehind)
Handled by iobj

iobjFor(PutIn)
handled on iobj

iobjFor(PutOn)
no description available

iobjFor(PutUnder)
Handled by iobj

iobjFor(ScrewWith)
no description available

iobjFor(ShowTo)
no description available

iobjFor(TakeFrom)
no description available

iobjFor(ThrowAt)
Modify the effects of throwing something at this object

iobjFor(ThrowTo)
no description available

iobjFor(TurnWith)
no description available

iobjFor(UnfastenFrom)
no description available

iobjFor(UnlockWith)
no description available

iobjFor(UnplugFrom)
no description available

iobjFor(UnscrewWith)
no description available

isAudibleFrom (pov)
Is this item audible from the remote location containing pov? By default it is if it's soundSize is not small, but this can be overridden, for example to vary with the pov.

isChild (obj, typ)
Are we a containment "child" of the given object with the given location type? This returns true if our location is the given object and our locType is the given type, or our location is a containment child of the given object with the given type. 'typ' is a LocType giving the relationship to test for, or nil. If it's nil, we'll return true if we have any containment relationship to 'obj'.

isDirectChild (obj, typ)
Are we a direct containment child of the given object with the given containment type? 'typ' is a LocType giving the relationship to test for, or nil. If it's nil, we'll return true if we have any direct containment relationship with 'obj'.

isDirectlyHeldBy (obj)
are we directly held by the given object?

isDirectlyIn (cont)
Are we directly in cont?

isDirectlyWornBy (obj)
are we directly worn by the given object?

isHeldBy (obj)
are we held by the given object, directly or indirectly?

isIn (cont)
Are we in cont?

isInterior (obj)
Am I on the inside of the given object? This returns true if our relationship to the given object is an interior location type.

isOrIsIn (cont)
Are either oont or in cont ?

isOutside (obj)
are we on the exterior of the given object, directly or indirectly?

isReadableFrom (pov)
Assuming this item is readable at all, is it readable from the remote location containing pov? By default we assume this is the case if and only if the item's sightSize is large, but this can be overridden, for example for a large item with small lettering.

isSmellableFrom (pov)
Is this item smellable from the remote location containing pov? By default it is if it's smellSize is not small, but this can be overridden, for example to vary with the pov.

isThereALightSourceIn (lst)
Determine (recursively) whether lst contains a light source; i.e. whether any of the items within list is lit or whether any of the visible contents of any of the items in lst it lit.

isVisibleFrom (pov)
Is this item visible from the remote location containing pov? By default it is if it's sightSize is not small, but this can be overridden, for example to vary with the pov.

isWornBy (obj)
are we worn by the given object, directly or indirectly?

knowsAbout (obj)
Test whether this Thing knows about obj, which it does either if it has seen this obj or its knownProp (by default, familiar) is true.

listableContentsOf (cont)
The subset of the contents of cont that should be listed.

listContents (lister, =, roomContentsLister)
List the contents of this object using lister.

listRemoteContents (lst, lister, pov)
List contents as seen from a remote location

listSubcontentsOf (contList, lister, =, examineLister)
List the contents of every item in contList, recursively listing the contents of contents all the way down the containment tree. The contList parameter can also be passed as a singleton object.

litWithin ( )
Is this object's interior lit? an object if the object itself is a light source, or anything directly inside shines outwards, or we can see out from within and our location shines inwards.

locationWhich (func)
no description available

locType ( )
Our location type with respect to our immediate container; e.g. are we In, On, Under or Behind it?

lookAroundWithin ( )
Look around within this Thing (Room or Booth) to provide a full description of this location as seen from within, including our headline name, our internal description, and a listing of our visible contents.

makeCleaned (stat)
Carry out the effects of cleaning. By default we just set the value of the isClean property, but game code could override this to carry out any side effects of cleaning, such as revealing the inscription on a dirty old gravestone.

makeFastened (stat)
Make something fastened or unfastened. By default we just change the value of its isFastened property, but game code could override this to provide further side-effects on particular objects.

makeLit (stat)
Make this object lit or unlit

makeLocked (stat)
Make us locked or ublocked. We define this as a method so that subclasses such as Door can override to produce side effects (such as locking or unlocking the other side).

makeMovedTo (loc)
Cause this object to be moved to loc

makeOn (stat)
switch this item on or off

makeOpen (stat)
Make us open or closed. We define this as a method so that subclasses such as Door can override to produce side effects (such as opening or closing the other side).

makeSetting (val)
This would be a good place to put code to validate the setting

makeWorn (stat)
Make this object worn or not worn. If this object is worn, presumably it's worn by its immediate location

moveHidden (prop, loc)
Service method: move everything in the prop property to loc and mark it as seen.

moveInto (newCont)
Basic moveInto for moving an object from one container to another by programmatic fiat.

nominalOwner ( )
Get my nominal owner. If we have an explicit owner, we'll return the first explicit owner. Otherwise, we'll look for a container that has ownsContents = true, and return the first such container.

noteSeen ( )
Note that we've been seen and where we were last seen

notifyInsert (obj)
Receive notification that obj is about to be inserted into us; by default we do nothing.

notifyRemove (obj)
Receive notification that obj is about to be removed from inside us; by default we do nothing.

notionalContents ( )
Our notional total contents is our normal contents plus anything contained in any of our remapXX objects representing our associated proxy container, surface, underside and rear, excluding anything in a closed opaque container (which would not be visible).

outermostParent ( )
Get my outermost parent. This is simply our ancestor in the location tree that has no location itself.

outermostVisibleParent ( )
no description available

ownedBy (obj)
Does the given object own me, explicitly or implicitly? This returns true if 'obj' is in my 'owner' list, but it can also return true if there's merely an implied ownership relationship. Location can imply ownership: BOB'S KEY could refer to the key that Bob is holding, whether or not it would continue to be considered his key if he were to drop it. We return true if 'obj' is an explicit owner, OR self is contained within 'obj', OR self is contained within an object owned by 'obj'. (The latter case is for things like BOB'S TWENTY DOLLAR BILL, which is Bob's by virtue of being inside a wallet explicitly owned by Bob.)

preinitThing ( )
Carry out the preinitialization of a Thing

pushTravelRevealItems ( )
Reveal items previously under or behind us that now become visible.

remoteInitSpecialDesc (pov)
Our remoteInitSpecialDesc, used when viewing this item from a remote location.By default we just show our ordinary initSpecialDesc, but in practice we'll normally want to override this.

remoteObjInName (pov)
The name given to this object when it's the container for another object viewed remotely, e.g. 'in the distant bucket' as opposed to just 'in the bucket'. By default we just use the objInName.

remoteSpecialDesc (pov)
Our remoteSpecialDesc is the paragraph describing this item in a room description when viewed from a remote location containing the pov object. By default we just show our ordinary specialDesc, but in practice we'll normally want to override this.

removeFromContents (obj, vec?)
Remove an item to this object's contents. Normally this method is used internally in the library than directly by game code. If the vec parameter is supplied, the object removed from our contents is also removed from vec; again this is intended primarily for internal use by the library.

revealOnMove ( )
List and move into an appropriate location any item that was hidden behind or under us. We place this in a separate method so it can be conveniently called by other actions that move an object, or overridden by particular objects that want a different handling. Note that we don't provide any handling for the hiddenIn property here, on the assumption that items hidden in something may well stay there when it's moved; but this method can always be overridden to provide custom behaviour.

roomHeadline (pov)
The title of this room to be displayed at the start of a room description, or in the status line.

scoreObject (cmd, role, lst, m)
Score this object for disambiguation. When a noun phrase is ambiguous (for example, the phrase matches multiple in-scope objects, and we have to choose just one), the parser calls this routine on each object it's considering as a match. Our job here is to read the player's mind. The question before us is: did the player mean *this* object when typing this noun phrase? Obviously we can't really know what's in the player's mind, but in many cases we can make an educated guess based on what ought to make the most sense in context. The context in this case is the state of the simulated game world, as it's portrayed to the player. That last bit is important: be cognizant of what the player is *meant* to know at this point. DON'T base the score on information that the player isn't supposed to know, though: that could give away secrets that the player is meant to discover on her own. Before this routine is called, the Action has already assigned an initial score to each object, but this routine can override the initial score by assigning its own score value. This routine is most useful in cases where a particular object has a special affinity for a verb, or for the verb in combination with particular other objects involved in the command. 'cmd' is the Command object. 'role' is the noun phrase's role in the command (DirectObject, IndirectObject, etc). 'lst' is a list of NPMatch objects identifying the objects that matched the noun phrase. 'm' is the NPMatch object for self. To override or adjust the score, simply set m.score to the new value. This routine is also free to override the scores of any other objects in the list, if needed. By default, we don't make any adjustment - we simply accept the initial score calculated by the Action, by leaving m.score unchanged. See Action.scoreObjects() for full details.

setHasSeen (obj)
Mark this Thing as having seen obj.

setKnown ( )
Mark the player character as knowing about us (i.e. this Thing)

setKnowsAbout (obj)
Mark this Thing as knowing about obj.

setSeen ( )
Mark the player character as having seen this Thing.

shinesOut ( )
Does this object shine light outwards? This determines if the object is a light source to objects outside of it. Light shines out from an object if the object itself is a light source, or one of its direct exterior contents shines out, or its contents are visible from the outside and one of its direct interior contents shines out.

showConnectedMiscContents (pov)
no description available

showFirstConnectedSpecials (pov)
no description available

showRemoteSpecialDesc (pov)
Show our remoteSpecialDesc, i.e. the version of our specialDesc that should be seen when this item is viewed from a remote location.

showSecondConnectedSpecials (pov)
no description available

showSpecialDesc ( )
Show our specialDesc or initSpecialDesc, as appropriate

showStatuslineExits ( )
Show our exits in the status line

statusName (actor)
Display the "status line" name of the room. This is normally a brief, single-line description. By long-standing convention, each location in a game usually has a distinctive name that's displayed here. Players usually find these names helpful in forming a mental map of the game. By default, if we have an enclosing location, and the actor can see the enclosing location, we'll defer to the location. Otherwise, we'll display our room interior name.

totalBulkIn (lst)
Calculate the total bulk of the items in lst

traceContainerPath (other, outFunc, parentFunc, inFunc)
Trace the interior containment path from 'self' to 'other'. We'll start by working up the containment tree from 'self' to the nearest interior container we have in common with 'other' - that is, the nearest object that contains both 'self' and 'other' with an interior location type for each object. For each container BELOW the common parent, we call outFunc(container). Next, we call parentFunc(container) on the common container. If there is no common container, we call parentFunc(nil). Next, we work back down the containment tree from the common parent to 'other'. For each container below the common parent, we call inFunc(container).

tryCheck (prop)
Run a check method passed as a property pointer in the prop parameter and return any string it tried to display

unmention (lst)
Mark everything item in lst as not mentioned , and carry on down the containment tree marking the contents of every item in lst as not mentioned.

unmentionRemoteContents ( )
The next four methods are provided so that listContents() can call them, but they do nothing in the core library. They are overridden in senseRegion.t (for use if senseRegion.t is included in the build).

verifyActor ( )
Next deal with what happens if this object is being tested as a potential actor

verifyPushTravel (via)
Common handler for verifying push travel actions. The via parameter may be a preposition object (such as Through) defining what kind of push traveling the actor is trying to do (e.g. through a door or up some stairs).

wouldBeLitFor (actor)
Would this location be lit for actor. By default it would if it's illuminated. 